{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/_classPrivateFieldLooseKey(\"provider\");\nvar _poller = /*#__PURE__*/_classPrivateFieldLooseKey(\"poller\");\nvar _interval = /*#__PURE__*/_classPrivateFieldLooseKey(\"interval\");\nvar _blockNumber = /*#__PURE__*/_classPrivateFieldLooseKey(\"blockNumber\");\nvar _poll = /*#__PURE__*/_classPrivateFieldLooseKey(\"poll\");\nexport class PollingBlockSubscriber {\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    Object.defineProperty(this, _poll, {\n      value: _poll2\n    });\n    Object.defineProperty(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _poller, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _interval, {\n      writable: true,\n      value: void 0\n    });\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    Object.defineProperty(this, _blockNumber, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _provider)[_provider] = provider;\n    _classPrivateFieldLooseBase(this, _poller)[_poller] = null;\n    _classPrivateFieldLooseBase(this, _interval)[_interval] = 4000;\n    _classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber] = -2;\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return _classPrivateFieldLooseBase(this, _interval)[_interval];\n  }\n  set pollingInterval(value) {\n    _classPrivateFieldLooseBase(this, _interval)[_interval] = value;\n  }\n  start() {\n    if (_classPrivateFieldLooseBase(this, _poller)[_poller]) {\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _poller)[_poller] = _classPrivateFieldLooseBase(this, _provider)[_provider]._setTimeout(_classPrivateFieldLooseBase(this, _poll)[_poll].bind(this), _classPrivateFieldLooseBase(this, _interval)[_interval]);\n    _classPrivateFieldLooseBase(this, _poll)[_poll]();\n  }\n  stop() {\n    if (!_classPrivateFieldLooseBase(this, _poller)[_poller]) {\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _provider)[_provider]._clearTimeout(_classPrivateFieldLooseBase(this, _poller)[_poller]);\n    _classPrivateFieldLooseBase(this, _poller)[_poller] = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber] = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll2() {\n  try {\n    const blockNumber = await _classPrivateFieldLooseBase(this, _provider)[_provider].getBlockNumber();\n    // Bootstrap poll to setup our initial block number\n    if (_classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber] === -2) {\n      _classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber] = blockNumber;\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== _classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber]) {\n      for (let b = _classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber] + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (_classPrivateFieldLooseBase(this, _poller)[_poller] == null) {\n          return;\n        }\n        await _classPrivateFieldLooseBase(this, _provider)[_provider].emit(\"block\", b);\n      }\n      _classPrivateFieldLooseBase(this, _blockNumber)[_blockNumber] = blockNumber;\n    }\n  } catch (error) {\n    // @TODO: Minor bump, add an \"error\" event to let subscribers\n    //        know things went awry.\n    //console.log(error);\n  }\n  // We have been stopped\n  if (_classPrivateFieldLooseBase(this, _poller)[_poller] == null) {\n    return;\n  }\n  _classPrivateFieldLooseBase(this, _poller)[_poller] = _classPrivateFieldLooseBase(this, _provider)[_provider]._setTimeout(_classPrivateFieldLooseBase(this, _poll)[_poll].bind(this), _classPrivateFieldLooseBase(this, _interval)[_interval]);\n}\nvar _provider2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"provider\");\nvar _poll3 = /*#__PURE__*/_classPrivateFieldLooseKey(\"poll\");\nvar _running = /*#__PURE__*/_classPrivateFieldLooseKey(\"running\");\nexport class OnBlockSubscriber {\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    Object.defineProperty(this, _provider2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _poll3, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _running, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _provider2)[_provider2] = provider;\n    _classPrivateFieldLooseBase(this, _running)[_running] = false;\n    _classPrivateFieldLooseBase(this, _poll3)[_poll3] = blockNumber => {\n      this._poll(blockNumber, _classPrivateFieldLooseBase(this, _provider2)[_provider2]);\n    };\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (_classPrivateFieldLooseBase(this, _running)[_running]) {\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _running)[_running] = true;\n    _classPrivateFieldLooseBase(this, _poll3)[_poll3](-2);\n    _classPrivateFieldLooseBase(this, _provider2)[_provider2].on(\"block\", _classPrivateFieldLooseBase(this, _poll3)[_poll3]);\n  }\n  stop() {\n    if (!_classPrivateFieldLooseBase(this, _running)[_running]) {\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _running)[_running] = false;\n    _classPrivateFieldLooseBase(this, _provider2)[_provider2].off(\"block\", _classPrivateFieldLooseBase(this, _poll3)[_poll3]);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nvar _tag = /*#__PURE__*/_classPrivateFieldLooseKey(\"tag\");\nvar _lastBlock = /*#__PURE__*/_classPrivateFieldLooseKey(\"lastBlock\");\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n  constructor(provider, tag) {\n    super(provider);\n    Object.defineProperty(this, _tag, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _lastBlock, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _tag)[_tag] = tag;\n    _classPrivateFieldLooseBase(this, _lastBlock)[_lastBlock] = -2;\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _classPrivateFieldLooseBase(this, _lastBlock)[_lastBlock] = -2;\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(_classPrivateFieldLooseBase(this, _tag)[_tag]);\n    if (block == null) {\n      return;\n    }\n    if (_classPrivateFieldLooseBase(this, _lastBlock)[_lastBlock] === -2) {\n      _classPrivateFieldLooseBase(this, _lastBlock)[_lastBlock] = block.number;\n    } else if (block.number > _classPrivateFieldLooseBase(this, _lastBlock)[_lastBlock]) {\n      provider.emit(_classPrivateFieldLooseBase(this, _tag)[_tag], block.number);\n      _classPrivateFieldLooseBase(this, _lastBlock)[_lastBlock] = block.number;\n    }\n  }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _filter = /*#__PURE__*/_classPrivateFieldLooseKey(\"filter\");\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  constructor(provider, filter) {\n    super(provider);\n    Object.defineProperty(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _filter)[_filter] = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(_classPrivateFieldLooseBase(this, _filter)[_filter]);\n  }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _hash = /*#__PURE__*/_classPrivateFieldLooseKey(\"hash\");\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    Object.defineProperty(this, _hash, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _hash)[_hash] = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(_classPrivateFieldLooseBase(this, _hash)[_hash]);\n    if (tx) {\n      provider.emit(_classPrivateFieldLooseBase(this, _hash)[_hash], tx);\n    }\n  }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider3 = /*#__PURE__*/_classPrivateFieldLooseKey(\"provider\");\nvar _filter2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"filter\");\nvar _poller2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"poller\");\nvar _running2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"running\");\nvar _blockNumber2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"blockNumber\");\nvar _poll4 = /*#__PURE__*/_classPrivateFieldLooseKey(\"poll\");\nexport class PollingEventSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, _filter3) {\n    Object.defineProperty(this, _poll4, {\n      value: _poll5\n    });\n    Object.defineProperty(this, _provider3, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _filter2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _poller2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _running2, {\n      writable: true,\n      value: void 0\n    });\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    Object.defineProperty(this, _blockNumber2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _provider3)[_provider3] = provider;\n    _classPrivateFieldLooseBase(this, _filter2)[_filter2] = copy(_filter3);\n    _classPrivateFieldLooseBase(this, _poller2)[_poller2] = _classPrivateFieldLooseBase(this, _poll4)[_poll4].bind(this);\n    _classPrivateFieldLooseBase(this, _running2)[_running2] = false;\n    _classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] = -2;\n  }\n  start() {\n    if (_classPrivateFieldLooseBase(this, _running2)[_running2]) {\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _running2)[_running2] = true;\n    if (_classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] === -2) {\n      _classPrivateFieldLooseBase(this, _provider3)[_provider3].getBlockNumber().then(blockNumber => {\n        _classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] = blockNumber;\n      });\n    }\n    _classPrivateFieldLooseBase(this, _provider3)[_provider3].on(\"block\", _classPrivateFieldLooseBase(this, _poller2)[_poller2]);\n  }\n  stop() {\n    if (!_classPrivateFieldLooseBase(this, _running2)[_running2]) {\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _running2)[_running2] = false;\n    _classPrivateFieldLooseBase(this, _provider3)[_provider3].off(\"block\", _classPrivateFieldLooseBase(this, _poller2)[_poller2]);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nasync function _poll5(blockNumber) {\n  // The initial block hasn't been determined yet\n  if (_classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] === -2) {\n    return;\n  }\n  const filter = copy(_classPrivateFieldLooseBase(this, _filter2)[_filter2]);\n  filter.fromBlock = _classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] + 1;\n  filter.toBlock = blockNumber;\n  const logs = await _classPrivateFieldLooseBase(this, _provider3)[_provider3].getLogs(filter);\n  // No logs could just mean the node has not indexed them yet,\n  // so we keep a sliding window of 60 blocks to keep scanning\n  if (logs.length === 0) {\n    if (_classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] < blockNumber - 60) {\n      _classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] = blockNumber - 60;\n    }\n    return;\n  }\n  for (const log of logs) {\n    _classPrivateFieldLooseBase(this, _provider3)[_provider3].emit(_classPrivateFieldLooseBase(this, _filter2)[_filter2], log);\n    // Only advance the block number when logs were found to\n    // account for networks (like BNB and Polygon) which may\n    // sacrifice event consistency for block event speed\n    _classPrivateFieldLooseBase(this, _blockNumber2)[_blockNumber2] = log.blockNumber;\n  }\n}","map":{"version":3,"names":["assert","isHexString","copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","PollingTransactionSubscriber","operation","info","_provider","_classPrivateFieldLooseKey","_poller","_interval","_blockNumber","_poll","constructor","Object","defineProperty","value","_poll2","writable","_classPrivateFieldLooseBase","pollingInterval","start","_setTimeout","bind","stop","_clearTimeout","pause","dropWhilePaused","resume","blockNumber","getBlockNumber","b","emit","error","_provider2","_poll3","_running","OnBlockSubscriber","Error","on","off","_tag","_lastBlock","PollingBlockTagSubscriber","tag","block","getBlock","number","_filter","PollingOrphanSubscriber","filter","console","log","_hash","hash","tx","getTransactionReceipt","_provider3","_filter2","_poller2","_running2","_blockNumber2","_poll4","PollingEventSubscriber","_poll5","then","fromBlock","toBlock","logs","getLogs","length"],"sources":["C:\\Users\\DELL\\Desktop\\decentralized-voting-dapp\\src\\node_modules\\ethers\\src.ts\\providers\\subscriber-polling.ts"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n\n            // @TODO: Put a cap on the maximum number of events per loop?\n\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) { return; }\n\n                    await this.#provider.emit(\"block\", b);\n                }\n\n                this.#blockNumber = blockNumber;\n            }\n\n        } catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { return; }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { return; }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    readonly #tag: string;\n    #lastBlock: number;\n\n    constructor(provider: AbstractProvider, tag: string) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused) { this.#lastBlock = -2; }\n        super.pause(dropWhilePaused);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) { return; }\n\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n\n\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}