{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\nimport { createGetUrl } from \"./geturl.js\";\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = createGetUrl();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n  try {\n    const match = url.match(reData);\n    if (!match) {\n      throw new Error(\"invalid data\");\n    }\n    return new FetchResponse(200, \"OK\", {\n      \"content-type\": match[1] || \"text/plain\"\n    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));\n  } catch (error) {\n    return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n  }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n  async function gatewayIpfs(url, signal) {\n    try {\n      const match = url.match(reIpfs);\n      if (!match) {\n        throw new Error(\"invalid link\");\n      }\n      return new FetchRequest(`${baseUrl}${match[2]}`);\n    } catch (error) {\n      return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n    }\n  }\n  return gatewayIpfs;\n}\nconst Gateways = {\n  \"data\": dataGatewayFunc,\n  \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nvar _listeners = /*#__PURE__*/_classPrivateFieldLooseKey(\"listeners\");\nvar _cancelled = /*#__PURE__*/_classPrivateFieldLooseKey(\"cancelled\");\nexport class FetchCancelSignal {\n  constructor(request) {\n    Object.defineProperty(this, _listeners, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _cancelled, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _listeners)[_listeners] = [];\n    _classPrivateFieldLooseBase(this, _cancelled)[_cancelled] = false;\n    fetchSignals.set(request, () => {\n      if (_classPrivateFieldLooseBase(this, _cancelled)[_cancelled]) {\n        return;\n      }\n      _classPrivateFieldLooseBase(this, _cancelled)[_cancelled] = true;\n      for (const listener of _classPrivateFieldLooseBase(this, _listeners)[_listeners]) {\n        setTimeout(() => {\n          listener();\n        }, 0);\n      }\n      _classPrivateFieldLooseBase(this, _listeners)[_listeners] = [];\n    });\n  }\n  addListener(listener) {\n    assert(!_classPrivateFieldLooseBase(this, _cancelled)[_cancelled], \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchCancelSignal.addCancelListener\"\n    });\n    _classPrivateFieldLooseBase(this, _listeners)[_listeners].push(listener);\n  }\n  get cancelled() {\n    return _classPrivateFieldLooseBase(this, _cancelled)[_cancelled];\n  }\n  checkSignal() {\n    assert(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n  }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n  if (signal == null) {\n    throw new Error(\"missing signal; should not happen\");\n  }\n  signal.checkSignal();\n  return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nvar _allowInsecure = /*#__PURE__*/_classPrivateFieldLooseKey(\"allowInsecure\");\nvar _gzip = /*#__PURE__*/_classPrivateFieldLooseKey(\"gzip\");\nvar _headers = /*#__PURE__*/_classPrivateFieldLooseKey(\"headers\");\nvar _method = /*#__PURE__*/_classPrivateFieldLooseKey(\"method\");\nvar _timeout = /*#__PURE__*/_classPrivateFieldLooseKey(\"timeout\");\nvar _url = /*#__PURE__*/_classPrivateFieldLooseKey(\"url\");\nvar _body = /*#__PURE__*/_classPrivateFieldLooseKey(\"body\");\nvar _bodyType = /*#__PURE__*/_classPrivateFieldLooseKey(\"bodyType\");\nvar _creds = /*#__PURE__*/_classPrivateFieldLooseKey(\"creds\");\nvar _preflight = /*#__PURE__*/_classPrivateFieldLooseKey(\"preflight\");\nvar _process = /*#__PURE__*/_classPrivateFieldLooseKey(\"process\");\nvar _retry = /*#__PURE__*/_classPrivateFieldLooseKey(\"retry\");\nvar _signal = /*#__PURE__*/_classPrivateFieldLooseKey(\"signal\");\nvar _throttle = /*#__PURE__*/_classPrivateFieldLooseKey(\"throttle\");\nvar _getUrlFunc = /*#__PURE__*/_classPrivateFieldLooseKey(\"getUrlFunc\");\nvar _send = /*#__PURE__*/_classPrivateFieldLooseKey(\"send\");\nexport class FetchRequest {\n  /**\n   *  The fetch URL to request.\n   */\n  get url() {\n    return _classPrivateFieldLooseBase(this, _url)[_url];\n  }\n  set url(url) {\n    _classPrivateFieldLooseBase(this, _url)[_url] = String(url);\n  }\n  /**\n   *  The fetch body, if any, to send as the request body. //(default: null)//\n   *\n   *  When setting a body, the intrinsic ``Content-Type`` is automatically\n   *  set and will be used if **not overridden** by setting a custom\n   *  header.\n   *\n   *  If %%body%% is null, the body is cleared (along with the\n   *  intrinsic ``Content-Type``).\n   *\n   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n   *  ``text/plain``.\n   *\n   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n   *  ``application/octet-stream``.\n   *\n   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n   *  set to ``application/json``.\n   */\n  get body() {\n    if (_classPrivateFieldLooseBase(this, _body)[_body] == null) {\n      return null;\n    }\n    return new Uint8Array(_classPrivateFieldLooseBase(this, _body)[_body]);\n  }\n  set body(body) {\n    if (body == null) {\n      _classPrivateFieldLooseBase(this, _body)[_body] = undefined;\n      _classPrivateFieldLooseBase(this, _bodyType)[_bodyType] = undefined;\n    } else if (typeof body === \"string\") {\n      _classPrivateFieldLooseBase(this, _body)[_body] = toUtf8Bytes(body);\n      _classPrivateFieldLooseBase(this, _bodyType)[_bodyType] = \"text/plain\";\n    } else if (body instanceof Uint8Array) {\n      _classPrivateFieldLooseBase(this, _body)[_body] = body;\n      _classPrivateFieldLooseBase(this, _bodyType)[_bodyType] = \"application/octet-stream\";\n    } else if (typeof body === \"object\") {\n      _classPrivateFieldLooseBase(this, _body)[_body] = toUtf8Bytes(JSON.stringify(body));\n      _classPrivateFieldLooseBase(this, _bodyType)[_bodyType] = \"application/json\";\n    } else {\n      throw new Error(\"invalid body\");\n    }\n  }\n  /**\n   *  Returns true if the request has a body.\n   */\n  hasBody() {\n    return _classPrivateFieldLooseBase(this, _body)[_body] != null;\n  }\n  /**\n   *  The HTTP method to use when requesting the URI. If no method\n   *  has been explicitly set, then ``GET`` is used if the body is\n   *  null and ``POST`` otherwise.\n   */\n  get method() {\n    if (_classPrivateFieldLooseBase(this, _method)[_method]) {\n      return _classPrivateFieldLooseBase(this, _method)[_method];\n    }\n    if (this.hasBody()) {\n      return \"POST\";\n    }\n    return \"GET\";\n  }\n  set method(method) {\n    if (method == null) {\n      method = \"\";\n    }\n    _classPrivateFieldLooseBase(this, _method)[_method] = String(method).toUpperCase();\n  }\n  /**\n   *  The headers that will be used when requesting the URI. All\n   *  keys are lower-case.\n   *\n   *  This object is a copy, so any changes will **NOT** be reflected\n   *  in the ``FetchRequest``.\n   *\n   *  To set a header entry, use the ``setHeader`` method.\n   */\n  get headers() {\n    const headers = Object.assign({}, _classPrivateFieldLooseBase(this, _headers)[_headers]);\n    if (_classPrivateFieldLooseBase(this, _creds)[_creds]) {\n      headers[\"authorization\"] = `Basic ${encodeBase64(toUtf8Bytes(_classPrivateFieldLooseBase(this, _creds)[_creds]))}`;\n    }\n    ;\n    if (this.allowGzip) {\n      headers[\"accept-encoding\"] = \"gzip\";\n    }\n    if (headers[\"content-type\"] == null && _classPrivateFieldLooseBase(this, _bodyType)[_bodyType]) {\n      headers[\"content-type\"] = _classPrivateFieldLooseBase(this, _bodyType)[_bodyType];\n    }\n    if (this.body) {\n      headers[\"content-length\"] = String(this.body.length);\n    }\n    return headers;\n  }\n  /**\n   *  Get the header for %%key%%, ignoring case.\n   */\n  getHeader(key) {\n    return this.headers[key.toLowerCase()];\n  }\n  /**\n   *  Set the header for %%key%% to %%value%%. All values are coerced\n   *  to a string.\n   */\n  setHeader(key, value) {\n    _classPrivateFieldLooseBase(this, _headers)[_headers][String(key).toLowerCase()] = String(value);\n  }\n  /**\n   *  Clear all headers, resetting all intrinsic headers.\n   */\n  clearHeaders() {\n    _classPrivateFieldLooseBase(this, _headers)[_headers] = {};\n  }\n  [Symbol.iterator]() {\n    const headers = this.headers;\n    const keys = Object.keys(headers);\n    let index = 0;\n    return {\n      next: () => {\n        if (index < keys.length) {\n          const key = keys[index++];\n          return {\n            value: [key, headers[key]],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   *  The value that will be sent for the ``Authorization`` header.\n   *\n   *  To set the credentials, use the ``setCredentials`` method.\n   */\n  get credentials() {\n    return _classPrivateFieldLooseBase(this, _creds)[_creds] || null;\n  }\n  /**\n   *  Sets an ``Authorization`` for %%username%% with %%password%%.\n   */\n  setCredentials(username, password) {\n    assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n    _classPrivateFieldLooseBase(this, _creds)[_creds] = `${username}:${password}`;\n  }\n  /**\n   *  Enable and request gzip-encoded responses. The response will\n   *  automatically be decompressed. //(default: true)//\n   */\n  get allowGzip() {\n    return _classPrivateFieldLooseBase(this, _gzip)[_gzip];\n  }\n  set allowGzip(value) {\n    _classPrivateFieldLooseBase(this, _gzip)[_gzip] = !!value;\n  }\n  /**\n   *  Allow ``Authentication`` credentials to be sent over insecure\n   *  channels. //(default: false)//\n   */\n  get allowInsecureAuthentication() {\n    return !!_classPrivateFieldLooseBase(this, _allowInsecure)[_allowInsecure];\n  }\n  set allowInsecureAuthentication(value) {\n    _classPrivateFieldLooseBase(this, _allowInsecure)[_allowInsecure] = !!value;\n  }\n  /**\n   *  The timeout (in milliseconds) to wait for a complete response.\n   *  //(default: 5 minutes)//\n   */\n  get timeout() {\n    return _classPrivateFieldLooseBase(this, _timeout)[_timeout];\n  }\n  set timeout(timeout) {\n    assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n    _classPrivateFieldLooseBase(this, _timeout)[_timeout] = timeout;\n  }\n  /**\n   *  This function is called prior to each request, for example\n   *  during a redirection or retry in case of server throttling.\n   *\n   *  This offers an opportunity to populate headers or update\n   *  content before sending a request.\n   */\n  get preflightFunc() {\n    return _classPrivateFieldLooseBase(this, _preflight)[_preflight] || null;\n  }\n  set preflightFunc(preflight) {\n    _classPrivateFieldLooseBase(this, _preflight)[_preflight] = preflight;\n  }\n  /**\n   *  This function is called after each response, offering an\n   *  opportunity to provide client-level throttling or updating\n   *  response data.\n   *\n   *  Any error thrown in this causes the ``send()`` to throw.\n   *\n   *  To schedule a retry attempt (assuming the maximum retry limit\n   *  has not been reached), use [[response.throwThrottleError]].\n   */\n  get processFunc() {\n    return _classPrivateFieldLooseBase(this, _process)[_process] || null;\n  }\n  set processFunc(process) {\n    _classPrivateFieldLooseBase(this, _process)[_process] = process;\n  }\n  /**\n   *  This function is called on each retry attempt.\n   */\n  get retryFunc() {\n    return _classPrivateFieldLooseBase(this, _retry)[_retry] || null;\n  }\n  set retryFunc(retry) {\n    _classPrivateFieldLooseBase(this, _retry)[_retry] = retry;\n  }\n  /**\n   *  This function is called to fetch content from HTTP and\n   *  HTTPS URLs and is platform specific (e.g. nodejs vs\n   *  browsers).\n   *\n   *  This is by default the currently registered global getUrl\n   *  function, which can be changed using [[registerGetUrl]].\n   *  If this has been set, setting is to ``null`` will cause\n   *  this FetchRequest (and any future clones) to revert back to\n   *  using the currently registered global getUrl function.\n   *\n   *  Setting this is generally not necessary, but may be useful\n   *  for developers that wish to intercept requests or to\n   *  configurege a proxy or other agent.\n   */\n  get getUrlFunc() {\n    return _classPrivateFieldLooseBase(this, _getUrlFunc)[_getUrlFunc] || defaultGetUrlFunc;\n  }\n  set getUrlFunc(value) {\n    _classPrivateFieldLooseBase(this, _getUrlFunc)[_getUrlFunc] = value;\n  }\n  /**\n   *  Create a new FetchRequest instance with default values.\n   *\n   *  Once created, each property may be set before issuing a\n   *  ``.send()`` to make the request.\n   */\n  constructor(url) {\n    Object.defineProperty(this, _send, {\n      value: _send2\n    });\n    Object.defineProperty(this, _allowInsecure, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _gzip, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _headers, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _method, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _timeout, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _url, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _body, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _bodyType, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _creds, {\n      writable: true,\n      value: void 0\n    });\n    // Hooks\n    Object.defineProperty(this, _preflight, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _process, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _retry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _signal, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _throttle, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getUrlFunc, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _url)[_url] = String(url);\n    _classPrivateFieldLooseBase(this, _allowInsecure)[_allowInsecure] = false;\n    _classPrivateFieldLooseBase(this, _gzip)[_gzip] = true;\n    _classPrivateFieldLooseBase(this, _headers)[_headers] = {};\n    _classPrivateFieldLooseBase(this, _method)[_method] = \"\";\n    _classPrivateFieldLooseBase(this, _timeout)[_timeout] = 300000;\n    _classPrivateFieldLooseBase(this, _throttle)[_throttle] = {\n      slotInterval: SLOT_INTERVAL,\n      maxAttempts: MAX_ATTEMPTS\n    };\n    _classPrivateFieldLooseBase(this, _getUrlFunc)[_getUrlFunc] = null;\n  }\n  toString() {\n    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${_classPrivateFieldLooseBase(this, _body)[_body] ? hexlify(_classPrivateFieldLooseBase(this, _body)[_body]) : \"null\"}>`;\n  }\n  /**\n   *  Update the throttle parameters used to determine maximum\n   *  attempts and exponential-backoff properties.\n   */\n  setThrottleParams(params) {\n    if (params.slotInterval != null) {\n      _classPrivateFieldLooseBase(this, _throttle)[_throttle].slotInterval = params.slotInterval;\n    }\n    if (params.maxAttempts != null) {\n      _classPrivateFieldLooseBase(this, _throttle)[_throttle].maxAttempts = params.maxAttempts;\n    }\n  }\n  /**\n   *  Resolves to the response by sending the request.\n   */\n  send() {\n    assert(_classPrivateFieldLooseBase(this, _signal)[_signal] == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchRequest.send\"\n    });\n    _classPrivateFieldLooseBase(this, _signal)[_signal] = new FetchCancelSignal(this);\n    return _classPrivateFieldLooseBase(this, _send)[_send](0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n  }\n  /**\n   *  Cancels the inflight response, causing a ``CANCELLED``\n   *  error to be rejected from the [[send]].\n   */\n  cancel() {\n    assert(_classPrivateFieldLooseBase(this, _signal)[_signal] != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchRequest.cancel\"\n    });\n    const signal = fetchSignals.get(this);\n    if (!signal) {\n      throw new Error(\"missing signal; should not happen\");\n    }\n    signal();\n  }\n  /**\n   *  Returns a new [[FetchRequest]] that represents the redirection\n   *  to %%location%%.\n   */\n  redirect(location) {\n    // Redirection; for now we only support absolute locations\n    const current = this.url.split(\":\")[0].toLowerCase();\n    const target = location.split(\":\")[0].toLowerCase();\n    // Don't allow redirecting:\n    // - non-GET requests\n    // - downgrading the security (e.g. https => http)\n    // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n    assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n    });\n    // Create a copy of this request, with a new URL\n    const req = new FetchRequest(location);\n    req.method = \"GET\";\n    req.allowGzip = this.allowGzip;\n    req.timeout = this.timeout;\n    _classPrivateFieldLooseBase(req, _headers)[_headers] = Object.assign({}, _classPrivateFieldLooseBase(this, _headers)[_headers]);\n    if (_classPrivateFieldLooseBase(this, _body)[_body]) {\n      _classPrivateFieldLooseBase(req, _body)[_body] = new Uint8Array(_classPrivateFieldLooseBase(this, _body)[_body]);\n    }\n    _classPrivateFieldLooseBase(req, _bodyType)[_bodyType] = _classPrivateFieldLooseBase(this, _bodyType)[_bodyType];\n    // Do not forward credentials unless on the same domain; only absolute\n    //req.allowInsecure = false;\n    // paths are currently supported; may want a way to specify to forward?\n    //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n    return req;\n  }\n  /**\n   *  Create a new copy of this request.\n   */\n  clone() {\n    const clone = new FetchRequest(this.url);\n    // Preserve \"default method\" (i.e. null)\n    _classPrivateFieldLooseBase(clone, _method)[_method] = _classPrivateFieldLooseBase(this, _method)[_method];\n    // Preserve \"default body\" with type, copying the Uint8Array is present\n    if (_classPrivateFieldLooseBase(this, _body)[_body]) {\n      _classPrivateFieldLooseBase(clone, _body)[_body] = _classPrivateFieldLooseBase(this, _body)[_body];\n    }\n    _classPrivateFieldLooseBase(clone, _bodyType)[_bodyType] = _classPrivateFieldLooseBase(this, _bodyType)[_bodyType];\n    // Preserve \"default headers\"\n    _classPrivateFieldLooseBase(clone, _headers)[_headers] = Object.assign({}, _classPrivateFieldLooseBase(this, _headers)[_headers]);\n    // Credentials is readonly, so we copy internally\n    _classPrivateFieldLooseBase(clone, _creds)[_creds] = _classPrivateFieldLooseBase(this, _creds)[_creds];\n    if (this.allowGzip) {\n      clone.allowGzip = true;\n    }\n    clone.timeout = this.timeout;\n    if (this.allowInsecureAuthentication) {\n      clone.allowInsecureAuthentication = true;\n    }\n    _classPrivateFieldLooseBase(clone, _preflight)[_preflight] = _classPrivateFieldLooseBase(this, _preflight)[_preflight];\n    _classPrivateFieldLooseBase(clone, _process)[_process] = _classPrivateFieldLooseBase(this, _process)[_process];\n    _classPrivateFieldLooseBase(clone, _retry)[_retry] = _classPrivateFieldLooseBase(this, _retry)[_retry];\n    _classPrivateFieldLooseBase(clone, _throttle)[_throttle] = Object.assign({}, _classPrivateFieldLooseBase(this, _throttle)[_throttle]);\n    _classPrivateFieldLooseBase(clone, _getUrlFunc)[_getUrlFunc] = _classPrivateFieldLooseBase(this, _getUrlFunc)[_getUrlFunc];\n    return clone;\n  }\n  /**\n   *  Locks all static configuration for gateways and FetchGetUrlFunc\n   *  registration.\n   */\n  static lockConfig() {\n    locked = true;\n  }\n  /**\n   *  Get the current Gateway function for %%scheme%%.\n   */\n  static getGateway(scheme) {\n    return Gateways[scheme.toLowerCase()] || null;\n  }\n  /**\n   *  Use the %%func%% when fetching URIs using %%scheme%%.\n   *\n   *  This method affects all requests globally.\n   *\n   *  If [[lockConfig]] has been called, no change is made and this\n   *  throws.\n   */\n  static registerGateway(scheme, func) {\n    scheme = scheme.toLowerCase();\n    if (scheme === \"http\" || scheme === \"https\") {\n      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n    }\n    if (locked) {\n      throw new Error(\"gateways locked\");\n    }\n    Gateways[scheme] = func;\n  }\n  /**\n   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n   *\n   *  This method affects all requests globally.\n   *\n   *  If [[lockConfig]] has been called, no change is made and this\n   *  throws.\n   */\n  static registerGetUrl(getUrl) {\n    if (locked) {\n      throw new Error(\"gateways locked\");\n    }\n    defaultGetUrlFunc = getUrl;\n  }\n  /**\n   *  Creates a getUrl function that fetches content from HTTP and\n   *  HTTPS URLs.\n   *\n   *  The available %%options%% are dependent on the platform\n   *  implementation of the default getUrl function.\n   *\n   *  This is not generally something that is needed, but is useful\n   *  when trying to customize simple behaviour when fetching HTTP\n   *  content.\n   */\n  static createGetUrlFunc(options) {\n    return createGetUrl(options);\n  }\n  /**\n   *  Creates a function that can \"fetch\" data URIs.\n   *\n   *  Note that this is automatically done internally to support\n   *  data URIs, so it is not necessary to register it.\n   *\n   *  This is not generally something that is needed, but may\n   *  be useful in a wrapper to perfom custom data URI functionality.\n   */\n  static createDataGateway() {\n    return dataGatewayFunc;\n  }\n  /**\n   *  Creates a function that will fetch IPFS (unvalidated) from\n   *  a custom gateway baseUrl.\n   *\n   *  The default IPFS gateway used internally is\n   *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n   */\n  static createIpfsGatewayFunc(baseUrl) {\n    return getIpfsGatewayFunc(baseUrl);\n  }\n}\nasync function _send2(attempt, expires, delay, _request, _response) {\n  if (attempt >= _classPrivateFieldLooseBase(this, _throttle)[_throttle].maxAttempts) {\n    return _response.makeServerError(\"exceeded maximum retry limit\");\n  }\n  assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n    operation: \"request.send\",\n    reason: \"timeout\",\n    request: _request\n  });\n  if (delay > 0) {\n    await wait(delay);\n  }\n  let req = this.clone();\n  const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n  // Process any Gateways\n  if (scheme in Gateways) {\n    const result = await Gateways[scheme](req.url, checkSignal(_classPrivateFieldLooseBase(_request, _signal)[_signal]));\n    if (result instanceof FetchResponse) {\n      let response = result;\n      if (this.processFunc) {\n        checkSignal(_classPrivateFieldLooseBase(_request, _signal)[_signal]);\n        try {\n          response = await this.processFunc(req, response);\n        } catch (error) {\n          // Something went wrong during processing; throw a 5xx server error\n          if (error.throttle == null || typeof error.stall !== \"number\") {\n            response.makeServerError(\"error in post-processing function\", error).assertOk();\n          }\n          // Ignore throttling\n        }\n      }\n      return response;\n    }\n    req = result;\n  }\n  // We have a preflight function; update the request\n  if (this.preflightFunc) {\n    req = await this.preflightFunc(req);\n  }\n  const resp = await this.getUrlFunc(req, checkSignal(_classPrivateFieldLooseBase(_request, _signal)[_signal]));\n  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n  if (response.statusCode === 301 || response.statusCode === 302) {\n    // Redirect\n    try {\n      const location = response.headers.location || \"\";\n      return _classPrivateFieldLooseBase(req.redirect(location), _send)[_send](attempt + 1, expires, 0, _request, response);\n    } catch (error) {}\n    // Things won't get any better on another attempt; abort\n    return response;\n  } else if (response.statusCode === 429) {\n    // Throttle\n    if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n      const retryAfter = response.headers[\"retry-after\"];\n      let delay = _classPrivateFieldLooseBase(this, _throttle)[_throttle].slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n      if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n        delay = parseInt(retryAfter);\n      }\n      return _classPrivateFieldLooseBase(req.clone(), _send)[_send](attempt + 1, expires, delay, _request, response);\n    }\n  }\n  if (this.processFunc) {\n    checkSignal(_classPrivateFieldLooseBase(_request, _signal)[_signal]);\n    try {\n      response = await this.processFunc(req, response);\n    } catch (error) {\n      // Something went wrong during processing; throw a 5xx server error\n      if (error.throttle == null || typeof error.stall !== \"number\") {\n        response.makeServerError(\"error in post-processing function\", error).assertOk();\n      }\n      // Throttle\n      let delay = _classPrivateFieldLooseBase(this, _throttle)[_throttle].slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n      ;\n      if (error.stall >= 0) {\n        delay = error.stall;\n      }\n      return _classPrivateFieldLooseBase(req.clone(), _send)[_send](attempt + 1, expires, delay, _request, response);\n    }\n  }\n  return response;\n}\n;\n/**\n *  The response for a FetchRequest.\n */\nvar _statusCode = /*#__PURE__*/_classPrivateFieldLooseKey(\"statusCode\");\nvar _statusMessage = /*#__PURE__*/_classPrivateFieldLooseKey(\"statusMessage\");\nvar _headers2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"headers\");\nvar _body2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"body\");\nvar _request2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"request\");\nvar _error = /*#__PURE__*/_classPrivateFieldLooseKey(\"error\");\nexport class FetchResponse {\n  toString() {\n    return `<FetchResponse status=${this.statusCode} body=${_classPrivateFieldLooseBase(this, _body2)[_body2] ? hexlify(_classPrivateFieldLooseBase(this, _body2)[_body2]) : \"null\"}>`;\n  }\n  /**\n   *  The response status code.\n   */\n  get statusCode() {\n    return _classPrivateFieldLooseBase(this, _statusCode)[_statusCode];\n  }\n  /**\n   *  The response status message.\n   */\n  get statusMessage() {\n    return _classPrivateFieldLooseBase(this, _statusMessage)[_statusMessage];\n  }\n  /**\n   *  The response headers. All keys are lower-case.\n   */\n  get headers() {\n    return Object.assign({}, _classPrivateFieldLooseBase(this, _headers2)[_headers2]);\n  }\n  /**\n   *  The response body, or ``null`` if there was no body.\n   */\n  get body() {\n    return _classPrivateFieldLooseBase(this, _body2)[_body2] == null ? null : new Uint8Array(_classPrivateFieldLooseBase(this, _body2)[_body2]);\n  }\n  /**\n   *  The response body as a UTF-8 encoded string, or the empty\n   *  string (i.e. ``\"\"``) if there was no body.\n   *\n   *  An error is thrown if the body is invalid UTF-8 data.\n   */\n  get bodyText() {\n    try {\n      return _classPrivateFieldLooseBase(this, _body2)[_body2] == null ? \"\" : toUtf8String(_classPrivateFieldLooseBase(this, _body2)[_body2]);\n    } catch (error) {\n      assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"bodyText\",\n        info: {\n          response: this\n        }\n      });\n    }\n  }\n  /**\n   *  The response body, decoded as JSON.\n   *\n   *  An error is thrown if the body is invalid JSON-encoded data\n   *  or if there was no body.\n   */\n  get bodyJson() {\n    try {\n      return JSON.parse(this.bodyText);\n    } catch (error) {\n      assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"bodyJson\",\n        info: {\n          response: this\n        }\n      });\n    }\n  }\n  [Symbol.iterator]() {\n    const headers = this.headers;\n    const keys = Object.keys(headers);\n    let index = 0;\n    return {\n      next: () => {\n        if (index < keys.length) {\n          const key = keys[index++];\n          return {\n            value: [key, headers[key]],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  constructor(statusCode, statusMessage, headers, body, request) {\n    Object.defineProperty(this, _statusCode, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _statusMessage, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _headers2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _body2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _request2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _error, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _statusCode)[_statusCode] = statusCode;\n    _classPrivateFieldLooseBase(this, _statusMessage)[_statusMessage] = statusMessage;\n    _classPrivateFieldLooseBase(this, _headers2)[_headers2] = Object.keys(headers).reduce((accum, k) => {\n      accum[k.toLowerCase()] = String(headers[k]);\n      return accum;\n    }, {});\n    _classPrivateFieldLooseBase(this, _body2)[_body2] = body == null ? null : new Uint8Array(body);\n    _classPrivateFieldLooseBase(this, _request2)[_request2] = request || null;\n    _classPrivateFieldLooseBase(this, _error)[_error] = {\n      message: \"\"\n    };\n  }\n  /**\n   *  Return a Response with matching headers and body, but with\n   *  an error status code (i.e. 599) and %%message%% with an\n   *  optional %%error%%.\n   */\n  makeServerError(message, error) {\n    let statusMessage;\n    if (!message) {\n      message = `${this.statusCode} ${this.statusMessage}`;\n      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n    } else {\n      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n    }\n    const response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldLooseBase(this, _request2)[_request2] || undefined);\n    _classPrivateFieldLooseBase(response, _error)[_error] = {\n      message,\n      error\n    };\n    return response;\n  }\n  /**\n   *  If called within a [request.processFunc](FetchRequest-processFunc)\n   *  call, causes the request to retry as if throttled for %%stall%%\n   *  milliseconds.\n   */\n  throwThrottleError(message, stall) {\n    if (stall == null) {\n      stall = -1;\n    } else {\n      assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n    }\n    const error = new Error(message || \"throttling requests\");\n    defineProperties(error, {\n      stall,\n      throttle: true\n    });\n    throw error;\n  }\n  /**\n   *  Get the header value for %%key%%, ignoring case.\n   */\n  getHeader(key) {\n    return this.headers[key.toLowerCase()];\n  }\n  /**\n   *  Returns true if the response has a body.\n   */\n  hasBody() {\n    return _classPrivateFieldLooseBase(this, _body2)[_body2] != null;\n  }\n  /**\n   *  The request made for this response.\n   */\n  get request() {\n    return _classPrivateFieldLooseBase(this, _request2)[_request2];\n  }\n  /**\n   *  Returns true if this response was a success statusCode.\n   */\n  ok() {\n    return _classPrivateFieldLooseBase(this, _error)[_error].message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n  }\n  /**\n   *  Throws a ``SERVER_ERROR`` if this response is not ok.\n   */\n  assertOk() {\n    if (this.ok()) {\n      return;\n    }\n    let {\n      message,\n      error\n    } = _classPrivateFieldLooseBase(this, _error)[_error];\n    if (message === \"\") {\n      message = `server response ${this.statusCode} ${this.statusMessage}`;\n    }\n    let requestUrl = null;\n    if (this.request) {\n      requestUrl = this.request.url;\n    }\n    let responseBody = null;\n    try {\n      if (_classPrivateFieldLooseBase(this, _body2)[_body2]) {\n        responseBody = toUtf8String(_classPrivateFieldLooseBase(this, _body2)[_body2]);\n      }\n    } catch (e) {}\n    assert(false, message, \"SERVER_ERROR\", {\n      request: this.request || \"unknown request\",\n      response: this,\n      error,\n      info: {\n        requestUrl,\n        responseBody,\n        responseStatus: `${this.statusCode} ${this.statusMessage}`\n      }\n    });\n  }\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction unpercent(value) {\n  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n    return String.fromCharCode(parseInt(code, 16));\n  }));\n}\nfunction wait(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay));\n}","map":{"version":3,"names":["decodeBase64","encodeBase64","hexlify","assert","assertArgument","defineProperties","toUtf8Bytes","toUtf8String","createGetUrl","MAX_ATTEMPTS","SLOT_INTERVAL","defaultGetUrlFunc","reData","RegExp","reIpfs","locked","dataGatewayFunc","url","signal","match","Error","FetchResponse","unpercent","error","FetchRequest","getIpfsGatewayFunc","baseUrl","gatewayIpfs","Gateways","fetchSignals","WeakMap","_listeners","_classPrivateFieldLooseKey","_cancelled","FetchCancelSignal","constructor","request","Object","defineProperty","writable","value","_classPrivateFieldLooseBase","set","listener","setTimeout","addListener","operation","push","cancelled","checkSignal","_allowInsecure","_gzip","_headers","_method","_timeout","_url","_body","_bodyType","_creds","_preflight","_process","_retry","_signal","_throttle","_getUrlFunc","_send","String","body","Uint8Array","undefined","JSON","stringify","hasBody","method","toUpperCase","headers","assign","allowGzip","length","getHeader","key","toLowerCase","setHeader","clearHeaders","Symbol","iterator","keys","index","next","done","credentials","setCredentials","username","password","allowInsecureAuthentication","timeout","preflightFunc","preflight","processFunc","process","retryFunc","retry","getUrlFunc","_send2","slotInterval","maxAttempts","toString","setThrottleParams","params","send","getTime","cancel","get","redirect","location","current","split","target","req","clone","lockConfig","getGateway","scheme","registerGateway","func","registerGetUrl","getUrl","createGetUrlFunc","options","createDataGateway","createIpfsGatewayFunc","attempt","expires","delay","_request","_response","makeServerError","reason","wait","result","response","throttle","stall","assertOk","resp","statusCode","statusMessage","retryAfter","Math","trunc","random","pow","parseInt","_statusCode","_statusMessage","_headers2","_body2","_request2","_error","bodyText","info","bodyJson","parse","reduce","accum","k","message","throwThrottleError","Number","isInteger","ok","requestUrl","responseBody","e","responseStatus","Date","replace","all","code","fromCharCode","Promise","resolve"],"sources":["C:\\Users\\DELL\\Desktop\\decentralized-voting-dapp\\src\\node_modules\\ethers\\src.ts\\utils\\fetch.ts"],"sourcesContent":["/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\n\nimport { createGetUrl } from \"./geturl.js\";\n\n/**\n *  An environment's implementation of ``getUrl`` must return this type.\n */\nexport type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};\n\n/**\n *  This can be used to control how throttling is handled in\n *  [[FetchRequest-setThrottleParams]].\n */\nexport type FetchThrottleParams = {\n    maxAttempts?: number;\n    slotInterval?: number;\n};\n\n/**\n *  Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.\n */\nexport type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;\n\n/**\n *  Called on the response, allowing client-based throttling logic or post-processing.\n */\nexport type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;\n\n/**\n *  Called prior to each retry; return true to retry, false to abort.\n */\nexport type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;\n\n/**\n *  Called on Gateway URLs.\n */\nexport type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;\n\n/**\n *  Used to perform a fetch; use this to override the underlying network\n *  fetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\n *  and in the browser ``fetch`` is used. If you wish to use Axios, this is\n *  how you would register it.\n */\nexport type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc: FetchGetUrlFunc = createGetUrl();\n\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n\n// If locked, new Gateways cannot be added\nlet locked = false;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url: string, signal?: FetchCancelSignal): Promise<FetchResponse> {\n    try {\n        const match = url.match(reData);\n        if (!match) { throw new Error(\"invalid data\"); }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? decodeBase64(match[3]): unpercent(match[3])));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", { }, null, new FetchRequest(url));\n    }\n}\n\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc {\n    async function gatewayIpfs(url: string, signal?: FetchCancelSignal): Promise<FetchRequest | FetchResponse> {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) { throw new Error(\"invalid link\"); }\n            return new FetchRequest(`${ baseUrl }${ match[2] }`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", { }, null, new FetchRequest(url));\n        }\n    }\n\n    return gatewayIpfs;\n}\n\nconst Gateways: Record<string, FetchGatewayFunc> = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\n\nconst fetchSignals: WeakMap<FetchRequest, () => void> = new WeakMap();\n\n/**\n *  @_ignore\n */\nexport class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            this.#cancelled = true;\n\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [ ];\n        });\n    }\n\n    addListener(listener: () => void): void {\n        assert(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n\n    get cancelled(): boolean { return this.#cancelled; }\n\n    checkSignal(): void {\n        assert(!this.cancelled, \"cancelled\", \"CANCELLED\", { });\n    }\n}\n\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal?: FetchCancelSignal): FetchCancelSignal {\n    if (signal == null) { throw new Error(\"missing signal; should not happen\"); }\n    signal.checkSignal();\n    return signal;\n}\n\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nexport class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n    // Hooks\n    #preflight?: null | FetchPreflightFunc;\n    #process?: null | FetchProcessFunc;\n    #retry?: null | FetchRetryFunc;\n\n    #signal?: FetchCancelSignal;\n\n    #throttle: Required<FetchThrottleParams>;\n\n    #getUrlFunc: null | FetchGetUrlFunc;\n\n    /**\n     *  The fetch URL to request.\n     */\n    get url(): string { return this.#url; }\n    set url(url: string) {\n        this.#url = String(url);\n    }\n\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body(): null | Uint8Array {\n        if (this.#body == null) { return null; }\n        return new Uint8Array(this.#body);\n    }\n    set body(body: null | string | Readonly<object> | Readonly<Uint8Array>) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof(body) === \"string\") {\n            this.#body = toUtf8Bytes(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof(body) === \"object\") {\n            this.#body = toUtf8Bytes(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody(): this is (FetchRequest & { body: Uint8Array }) {\n        return (this.#body != null);\n    }\n\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method(): string {\n        if (this.#method) { return this.#method; }\n        if (this.hasBody()) { return \"POST\"; }\n        return \"GET\";\n    }\n    set method(method: null | string) {\n        if (method == null) { method = \"\"; }\n        this.#method = String(method).toUpperCase();\n    }\n\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers(): Record<string, string> {\n        const headers = Object.assign({ }, this.#headers);\n\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${ encodeBase64(toUtf8Bytes(this.#creds)) }`;\n        };\n\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) { headers[\"content-length\"] = String(this.body.length); }\n\n        return headers;\n    }\n\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key: string): string {\n        return this.headers[key.toLowerCase()];\n    }\n\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key: string, value: string | number): void {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders(): void {\n        this.#headers = { };\n    }\n\n    [Symbol.iterator](): Iterator<[ key: string, value: string ]> {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [ key, headers[key] ], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials(): null | string {\n        return this.#creds || null;\n    }\n\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username: string, password: string): void {\n        assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${ username }:${ password }`;\n    }\n\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip(): boolean {\n        return this.#gzip;\n    }\n    set allowGzip(value: boolean) {\n        this.#gzip = !!value;\n    }\n\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication(): boolean {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value: boolean) {\n        this.#allowInsecure = !!value;\n    }\n\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout(): number { return this.#timeout; }\n    set timeout(timeout: number) {\n        assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc(): null | FetchPreflightFunc {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight: null | FetchPreflightFunc) {\n        this.#preflight = preflight;\n    }\n\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc(): null | FetchProcessFunc {\n        return this.#process || null;\n    }\n    set processFunc(process: null | FetchProcessFunc) {\n        this.#process = process;\n    }\n\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc(): null | FetchRetryFunc {\n        return this.#retry || null;\n    }\n    set retryFunc(retry: null | FetchRetryFunc) {\n        this.#retry = retry;\n    }\n\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */\n    get getUrlFunc(): FetchGetUrlFunc {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value: null | FetchGetUrlFunc) {\n        this.#getUrlFunc = value;\n    }\n\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url: string) {\n        this.#url = String(url);\n\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = { };\n        this.#method = \"\";\n        this.#timeout = 300000;\n\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n\n        this.#getUrlFunc = null;\n    }\n\n    toString(): string {\n        return `<FetchRequest method=${ JSON.stringify(this.method) } url=${ JSON.stringify(this.url) } headers=${ JSON.stringify(this.headers) } body=${ this.#body ? hexlify(this.#body): \"null\" }>`;\n    }\n\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params: FetchThrottleParams): void {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n\n    async #send(attempt: number, expires: number, delay: number, _request: FetchRequest, _response: FetchResponse): Promise<FetchResponse> {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n\n        assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n\n        if (delay > 0) { await wait(delay); }\n\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error: any) {\n\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof(error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n\n                        // Ignore throttling\n                    }\n                }\n\n                return response;\n            }\n            req = result;\n        }\n\n        // We have a preflight function; update the request\n        if (this.preflightFunc) { req = await this.preflightFunc(req); }\n\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n\n        if (response.statusCode === 301 || response.statusCode === 302) {\n\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) { }\n\n            // Things won't get any better on another attempt; abort\n            return response;\n\n        } else if (response.statusCode === 429) {\n\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error: any) {\n\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof(error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));;\n                if (error.stall >= 0) { delay = error.stall; }\n\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n\n        return response;\n    }\n\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send(): Promise<FetchResponse> {\n        assert(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", { }, null, this));\n    }\n\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel(): void {\n        assert(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) { throw new Error(\"missing signal; should not happen\"); }\n        signal();\n    }\n\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location: string): FetchRequest {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${ this.method } ${ JSON.stringify(this.url) } => ${ JSON.stringify(location) })`\n        });\n\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({ }, this.#headers);\n        if (this.#body) { req.#body = new Uint8Array(this.#body); }\n        req.#bodyType = this.#bodyType;\n\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n\n        return req;\n    }\n\n    /**\n     *  Create a new copy of this request.\n     */\n    clone(): FetchRequest {\n        const clone = new FetchRequest(this.url);\n\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) { clone.#body = this.#body; }\n        clone.#bodyType = this.#bodyType;\n\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({ }, this.#headers);\n\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n\n        if (this.allowGzip) { clone.allowGzip = true; }\n\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) { clone.allowInsecureAuthentication = true; }\n\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n\n        clone.#throttle = Object.assign({ }, this.#throttle);\n\n        clone.#getUrlFunc = this.#getUrlFunc;\n\n        return clone;\n    }\n\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig(): void {\n        locked = true;\n    }\n\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme: string): null | FetchGatewayFunc {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme: string, func: FetchGatewayFunc): void {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${ scheme }; use registerGetUrl`);\n        }\n        if (locked) { throw new Error(\"gateways locked\"); }\n        Gateways[scheme] = func;\n    }\n\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl: FetchGetUrlFunc): void {\n        if (locked) { throw new Error(\"gateways locked\"); }\n        defaultGetUrlFunc = getUrl;\n    }\n\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */\n    static createGetUrlFunc(options?: Record<string, any>): FetchGetUrlFunc {\n        return createGetUrl(options);\n    }\n\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway(): FetchGatewayFunc {\n        return dataGatewayFunc;\n    }\n\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n\n\ninterface ThrottleError extends Error {\n    stall: number;\n    throttle: true;\n};\n\n/**\n *  The response for a FetchRequest.\n */\nexport class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n    toString(): string {\n        return `<FetchResponse status=${ this.statusCode } body=${ this.#body ? hexlify(this.#body): \"null\" }>`;\n    }\n\n    /**\n     *  The response status code.\n     */\n    get statusCode(): number { return this.#statusCode; }\n\n    /**\n     *  The response status message.\n     */\n    get statusMessage(): string { return this.#statusMessage; }\n\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers(): Record<string, string> { return Object.assign({ }, this.#headers); }\n\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body(): null | Readonly<Uint8Array> {\n        return (this.#body == null) ? null: new Uint8Array(this.#body);\n    }\n\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText(): string {\n        try {\n            return (this.#body == null) ? \"\": toUtf8String(this.#body);\n        } catch (error) {\n            assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson(): any {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n\n    [Symbol.iterator](): Iterator<[ key: string, value: string ]> {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [ key, headers[key] ], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    constructor(statusCode: number, statusMessage: string, headers: Readonly<Record<string, string>>, body: null | Uint8Array, request?: FetchRequest) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, <Record<string, string>>{ });\n        this.#body = ((body == null) ? null: new Uint8Array(body));\n        this.#request = (request || null);\n\n        this.#error = { message: \"\" };\n    }\n\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message?: string, error?: Error): FetchResponse {\n        let statusMessage: string;\n        if (!message) {\n            message = `${ this.statusCode } ${ this.statusMessage }`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${ message })`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${ this.statusCode } ${ this.statusMessage }; ${ message })`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers,\n            this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message?: string, stall?: number): never {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n\n        const error = new Error(message || \"throttling requests\");\n\n        defineProperties(<ThrottleError>error, { stall, throttle: true });\n\n        throw error;\n    }\n\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key: string): string {\n        return this.headers[key.toLowerCase()];\n    }\n\n    /**\n     *  Returns true if the response has a body.\n     */\n    hasBody(): this is (FetchResponse & { body: Uint8Array }) {\n        return (this.#body != null);\n    }\n\n    /**\n     *  The request made for this response.\n     */\n    get request(): null | FetchRequest { return this.#request; }\n\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok(): boolean {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk(): void {\n        if (this.ok()) { return; }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${ this.statusCode } ${ this.statusMessage }`;\n        }\n\n        let requestUrl: null | string = null;\n        if (this.request) { requestUrl = this.request.url; }\n\n        let responseBody: null | string = null;\n        try {\n            if (this.#body) { responseBody = toUtf8String(this.#body); }\n        } catch (e) { }\n\n        assert(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error,\n            info: {\n                requestUrl, responseBody,\n                responseStatus: `${ this.statusCode } ${ this.statusMessage }` }\n        });\n    }\n}\n\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\nfunction wait(delay: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}