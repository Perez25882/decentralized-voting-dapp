{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\nimport { id } from \"../hash/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\nimport { decodeOwl } from \"./decode-owl.js\";\nimport { Wordlist } from \"./wordlist.js\";\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nvar _data = /*#__PURE__*/_classPrivateFieldLooseKey(\"data\");\nvar _checksum = /*#__PURE__*/_classPrivateFieldLooseKey(\"checksum\");\nvar _words = /*#__PURE__*/_classPrivateFieldLooseKey(\"words\");\nvar _loadWords = /*#__PURE__*/_classPrivateFieldLooseKey(\"loadWords\");\nexport class WordlistOwl extends Wordlist {\n  /**\n   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n   *  and validated against the %%checksum%%.\n   */\n  constructor(locale, data, _checksum2) {\n    super(locale);\n    Object.defineProperty(this, _loadWords, {\n      value: _loadWords2\n    });\n    Object.defineProperty(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _checksum, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _words, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _data)[_data] = data;\n    _classPrivateFieldLooseBase(this, _checksum)[_checksum] = _checksum2;\n    _classPrivateFieldLooseBase(this, _words)[_words] = null;\n  }\n  /**\n   *  The OWL-encoded data.\n   */\n  get _data() {\n    return _classPrivateFieldLooseBase(this, _data)[_data];\n  }\n  /**\n   *  Decode all the words for the wordlist.\n   */\n  _decodeWords() {\n    return decodeOwl(_classPrivateFieldLooseBase(this, _data)[_data]);\n  }\n  getWord(index) {\n    const words = _classPrivateFieldLooseBase(this, _loadWords)[_loadWords]();\n    assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n    return words[index];\n  }\n  getWordIndex(word) {\n    return _classPrivateFieldLooseBase(this, _loadWords)[_loadWords]().indexOf(word);\n  }\n}\nfunction _loadWords2() {\n  if (_classPrivateFieldLooseBase(this, _words)[_words] == null) {\n    const words = this._decodeWords();\n    // Verify the computed list matches the official list\n    const checksum = id(words.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */\n    if (checksum !== _classPrivateFieldLooseBase(this, _checksum)[_checksum]) {\n      throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\n    }\n    /* c8 ignore stop */\n    _classPrivateFieldLooseBase(this, _words)[_words] = words;\n  }\n  return _classPrivateFieldLooseBase(this, _words)[_words];\n}","map":{"version":3,"names":["id","assertArgument","decodeOwl","Wordlist","_data","_classPrivateFieldLooseKey","_checksum","_words","_loadWords","WordlistOwl","constructor","locale","data","checksum","Object","defineProperty","value","_loadWords2","writable","_classPrivateFieldLooseBase","_decodeWords","getWord","index","words","length","getWordIndex","word","indexOf","join","Error"],"sources":["C:\\Users\\DELL\\Desktop\\decentralized-voting-dapp\\src\\node_modules\\ethers\\src.ts\\wordlists\\wordlist-owl.ts"],"sourcesContent":["\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\n\nimport { id } from \"../hash/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\n\nimport { decodeOwl } from \"./decode-owl.js\";\nimport { Wordlist } from \"./wordlist.js\";\n\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nexport class WordlistOwl extends Wordlist {\n    #data: string;\n    #checksum: string;\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, checksum: string) {\n        super(locale);\n        this.#data = data;\n        this.#checksum = checksum;\n        this.#words = null;\n    }\n\n    /**\n     *  The OWL-encoded data.\n     */\n    get _data(): string { return this.#data; }\n\n    /**\n     *  Decode all the words for the wordlist.\n     */\n    _decodeWords(): Array<string> {\n        return decodeOwl(this.#data);\n    }\n\n    #words: null | Array<string>;\n    #loadWords(): Array<string> {\n        if (this.#words == null) {\n            const words = this._decodeWords();\n\n            // Verify the computed list matches the official list\n            const checksum = id(words.join(\"\\n\") + \"\\n\");\n            /* c8 ignore start */\n            if (checksum !== this.#checksum) {\n                throw new Error(`BIP39 Wordlist for ${ this.locale } FAILED`);\n            }\n            /* c8 ignore stop */\n\n            this.#words = words;\n        }\n        return this.#words;\n    }\n\n    getWord(index: number): string {\n        const words = this.#loadWords();\n        assertArgument(index >= 0 && index < words.length, `invalid word index: ${ index }`, \"index\", index);\n        return words[index];\n    }\n\n    getWordIndex(word: string): number {\n        return this.#loadWords().indexOf(word);\n    }\n}\n"],"mappings":";;AACA;AACA;AAEA,SAASA,EAAE,QAAQ,kBAAkB;AACrC,SAASC,cAAc,QAAQ,mBAAmB;AAElD,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,QAAQ,QAAQ,eAAe;AAExC;;;;;;;;;;;;AAAA,IAAAC,KAAA,gBAAAC,0BAAA;AAAA,IAAAC,SAAA,gBAAAD,0BAAA;AAAA,IAAAE,MAAA,gBAAAF,0BAAA;AAAA,IAAAG,UAAA,gBAAAH,0BAAA;AAYA,OAAM,MAAOI,WAAY,SAAQN,QAAQ;EAIrC;;;;EAIAO,YAAYC,MAAc,EAAEC,IAAY,EAAEC,UAAgB;IACtD,KAAK,CAACF,MAAM,CAAC;IAACG,MAAA,CAAAC,cAAA,OAAAP,UAAA;MAAAQ,KAAA,EAAAC;IAAA;IAAAH,MAAA,CAAAC,cAAA,OAAAX,KAAA;MAAAc,QAAA;MAAAF,KAAA;IAAA;IAAAF,MAAA,CAAAC,cAAA,OAAAT,SAAA;MAAAY,QAAA;MAAAF,KAAA;IAAA;IAAAF,MAAA,CAAAC,cAAA,OAAAR,MAAA;MAAAW,QAAA;MAAAF,KAAA;IAAA;IACdG,2BAAA,KAAI,EAAAf,KAAA,EAAAA,KAAA,IAASQ,IAAI;IACjBO,2BAAA,KAAI,EAAAb,SAAA,EAAAA,SAAA,IAAaO,UAAQ;IACzBM,2BAAA,KAAI,EAAAZ,MAAA,EAAAA,MAAA,IAAU,IAAI;EACtB;EAEA;;;EAGA,IAAIH,KAAKA,CAAA;IAAa,OAAAe,2BAAA,CAAO,IAAI,EAAAf,KAAA,EAAAA,KAAA;EAAQ;EAEzC;;;EAGAgB,YAAYA,CAAA;IACR,OAAOlB,SAAS,CAAAiB,2BAAA,CAAC,IAAI,EAAAf,KAAA,EAAAA,KAAA,CAAM,CAAC;EAChC;EAoBAiB,OAAOA,CAACC,KAAa;IACjB,MAAMC,KAAK,GAAAJ,2BAAA,CAAG,IAAI,EAAAX,UAAA,EAAAA,UAAA,GAAa;IAC/BP,cAAc,CAACqB,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGC,KAAK,CAACC,MAAM,EAAE,uBAAwBF,KAAM,EAAE,EAAE,OAAO,EAAEA,KAAK,CAAC;IACpG,OAAOC,KAAK,CAACD,KAAK,CAAC;EACvB;EAEAG,YAAYA,CAACC,IAAY;IACrB,OAAOP,2BAAA,KAAI,EAAAX,UAAA,EAAAA,UAAA,IAAcmB,OAAO,CAACD,IAAI,CAAC;EAC1C;;AACH,SAAAT,YAAA,EA1Ba;EACN,IAAIE,2BAAA,KAAI,EAAAZ,MAAA,EAAAA,MAAA,KAAW,IAAI,EAAE;IACrB,MAAMgB,KAAK,GAAG,IAAI,CAACH,YAAY,EAAE;IAEjC;IACA,MAAMP,QAAQ,GAAGb,EAAE,CAACuB,KAAK,CAACK,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;IAC5C;IACA,IAAIf,QAAQ,KAAAM,2BAAA,CAAK,IAAI,EAAAb,SAAA,EAAAA,SAAA,CAAU,EAAE;MAC7B,MAAM,IAAIuB,KAAK,CAAC,sBAAuB,IAAI,CAAClB,MAAO,SAAS,CAAC;;IAEjE;IAEAQ,2BAAA,KAAI,EAAAZ,MAAA,EAAAA,MAAA,IAAUgB,KAAK;;EAEvB,OAAAJ,2BAAA,CAAO,IAAI,EAAAZ,MAAA,EAAAA,MAAA;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}