{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\nimport { defineProperties } from \"./properties.js\";\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nvar _listener = /*#__PURE__*/_classPrivateFieldLooseKey(\"listener\");\nexport class EventPayload {\n  /**\n   *  Create a new **EventPayload** for %%emitter%% with\n   *  the %%listener%% and for %%filter%%.\n   */\n  constructor(emitter, listener, filter) {\n    /**\n     *  The event filter.\n     */\n    /**\n     *  The **EventEmitterable**.\n     */\n    Object.defineProperty(this, _listener, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _listener)[_listener] = listener;\n    defineProperties(this, {\n      emitter,\n      filter\n    });\n  }\n  /**\n   *  Unregister the triggered listener for future events.\n   */\n  async removeListener() {\n    if (_classPrivateFieldLooseBase(this, _listener)[_listener] == null) {\n      return;\n    }\n    await this.emitter.off(this.filter, _classPrivateFieldLooseBase(this, _listener)[_listener]);\n  }\n}","map":{"version":3,"names":["defineProperties","_listener","_classPrivateFieldLooseKey","EventPayload","constructor","emitter","listener","filter","Object","defineProperty","writable","value","_classPrivateFieldLooseBase","removeListener","off"],"sources":["C:\\Users\\DELL\\Desktop\\decentralized-voting-dapp\\src\\node_modules\\ethers\\src.ts\\utils\\events.ts"],"sourcesContent":["/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\nimport { defineProperties } from \"./properties.js\";\n\n/**\n *  A callback function called when a an event is triggered.\n */\nexport type Listener = (...args: Array<any>) => void;\n\n/**\n *  An **EventEmitterable** behaves similar to an EventEmitter\n *  except provides async access to its methods.\n *\n *  An EventEmitter implements the observer pattern.\n */\nexport interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event%% occurs.\n     */\n    once(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Triggers each listener for %%event%% with the %%args%%.\n     */\n    emit(event: T, ...args: Array<any>): Promise<boolean>;\n\n    /**\n     *  Resolves to the number of listeners for %%event%%.\n     */\n    listenerCount(event?: T): Promise<number>;\n\n    /**\n     *  Resolves to the listeners for %%event%%.\n     */\n    listeners(event?: T): Promise<Array<Listener>>;\n\n    /**\n     *  Unregister the %%listener%% for %%event%%. If %%listener%%\n     *  is unspecified, all listeners are unregistered.\n     */\n    off(event: T, listener?: Listener): Promise<this>;\n\n    /**\n     *  Unregister all listeners for %%event%%.\n     */\n    removeAllListeners(event?: T): Promise<this>;\n\n    /**\n     *  Alias for [[on]].\n     */\n    addListener(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Alias for [[off]].\n     */\n    removeListener(event: T, listener: Listener): Promise<this>;\n}\n\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nexport class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter: EventEmitterable<T>, listener: null | Listener, filter: T) {\n        this.#listener = listener;\n        defineProperties<EventPayload<any>>(this, { emitter, filter });\n    }\n\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener(): Promise<void> {\n        if (this.#listener == null) { return; }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\n"],"mappings":";;AAAA;;;;;;;AAOA,SAASA,gBAAgB,QAAQ,iBAAiB;AA+DlD;;;;;AAAA,IAAAC,SAAA,gBAAAC,0BAAA;AAKA,OAAM,MAAOC,YAAY;EAarB;;;;EAIAC,YAAYC,OAA4B,EAAEC,QAAyB,EAAEC,MAAS;IAhB9E;;;IAKA;;;IAAAC,MAAA,CAAAC,cAAA,OAAAR,SAAA;MAAAS,QAAA;MAAAC,KAAA;IAAA;IAYIC,2BAAA,KAAI,EAAAX,SAAA,EAAAA,SAAA,IAAaK,QAAQ;IACzBN,gBAAgB,CAAoB,IAAI,EAAE;MAAEK,OAAO;MAAEE;IAAM,CAAE,CAAC;EAClE;EAEA;;;EAGA,MAAMM,cAAcA,CAAA;IAChB,IAAID,2BAAA,KAAI,EAAAX,SAAA,EAAAA,SAAA,KAAc,IAAI,EAAE;MAAE;;IAC9B,MAAM,IAAI,CAACI,OAAO,CAACS,GAAG,CAAC,IAAI,CAACP,MAAM,EAAAK,2BAAA,CAAE,IAAI,EAAAX,SAAA,EAAAA,SAAA,CAAU,CAAC;EACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}