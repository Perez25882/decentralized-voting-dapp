{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport { WebSocket as _WebSocket } from \"./ws.js\"; /*-browser*/\nimport { SocketProvider } from \"./provider-socket.js\";\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nvar _connect = /*#__PURE__*/_classPrivateFieldLooseKey(\"connect\");\nvar _websocket = /*#__PURE__*/_classPrivateFieldLooseKey(\"websocket\");\nexport class WebSocketProvider extends SocketProvider {\n  get websocket() {\n    if (_classPrivateFieldLooseBase(this, _websocket)[_websocket] == null) {\n      throw new Error(\"websocket closed\");\n    }\n    return _classPrivateFieldLooseBase(this, _websocket)[_websocket];\n  }\n  constructor(url, network, options) {\n    super(network, options);\n    Object.defineProperty(this, _connect, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    if (typeof url === \"string\") {\n      _classPrivateFieldLooseBase(this, _connect)[_connect] = () => {\n        return new _WebSocket(url);\n      };\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = _classPrivateFieldLooseBase(this, _connect)[_connect]();\n    } else if (typeof url === \"function\") {\n      _classPrivateFieldLooseBase(this, _connect)[_connect] = url;\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = url();\n    } else {\n      _classPrivateFieldLooseBase(this, _connect)[_connect] = null;\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = url;\n    }\n    this.websocket.onopen = async () => {\n      try {\n        await this._start();\n        this.resume();\n      } catch (error) {\n        console.log(\"failed to start WebsocketProvider\", error);\n        // @TODO: now what? Attempt reconnect?\n      }\n    };\n    this.websocket.onmessage = message => {\n      this._processMessage(message.data);\n    };\n    /*\n            this.websocket.onclose = (event) => {\n                // @TODO: What event.code should we reconnect on?\n                const reconnect = false;\n                if (reconnect) {\n                    this.pause(true);\n                    if (this.#connect) {\n                        this.#websocket = this.#connect();\n                        this.#websocket.onopen = ...\n                        // @TODO: this requires the super class to rebroadcast; move it there\n                    }\n                    this._reconnect();\n                }\n            };\n    */\n  }\n  async _write(message) {\n    this.websocket.send(message);\n  }\n  async destroy() {\n    if (_classPrivateFieldLooseBase(this, _websocket)[_websocket] != null) {\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].close();\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n    }\n    super.destroy();\n  }\n}","map":{"version":3,"names":["WebSocket","_WebSocket","SocketProvider","_connect","_classPrivateFieldLooseKey","_websocket","WebSocketProvider","websocket","_classPrivateFieldLooseBase","Error","constructor","url","network","options","Object","defineProperty","writable","value","onopen","_start","resume","error","console","log","onmessage","message","_processMessage","data","_write","send","destroy","close"],"sources":["C:\\Users\\DELL\\Desktop\\decentralized-voting-dapp\\src\\node_modules\\ethers\\src.ts\\providers\\provider-websocket.ts"],"sourcesContent":["\n\nimport { WebSocket as _WebSocket } from \"./ws.js\"; /*-browser*/\n\nimport { SocketProvider } from \"./provider-socket.js\";\n\nimport type { JsonRpcApiProviderOptions} from \"./provider-jsonrpc.js\";\nimport type { Networkish } from \"./network.js\";\n\n/**\n *  A generic interface to a Websocket-like object.\n */\nexport interface WebSocketLike {\n    onopen: null | ((...args: Array<any>) => any);\n    onmessage: null | ((...args: Array<any>) => any);\n    onerror: null | ((...args: Array<any>) => any);\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}\n\n/**\n *  A function which can be used to re-create a WebSocket connection\n *  on disconnect.\n */\nexport type WebSocketCreator = () => WebSocketLike;\n\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nexport class WebSocketProvider extends SocketProvider {\n    #connect: null | WebSocketCreator;\n\n    #websocket: null | WebSocketLike;\n    get websocket(): WebSocketLike {\n        if (this.#websocket == null) { throw new Error(\"websocket closed\"); }\n        return this.#websocket;\n    }\n\n    constructor(url: string | WebSocketLike | WebSocketCreator, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n        if (typeof(url) === \"string\") {\n            this.#connect = () => { return new _WebSocket(url); };\n            this.#websocket = this.#connect();\n        } else if (typeof(url) === \"function\") {\n            this.#connect = url;\n            this.#websocket = url();\n        } else {\n            this.#connect = null;\n            this.#websocket = url;\n        }\n\n        this.websocket.onopen = async () => {\n            try {\n                await this._start()\n                this.resume();\n            } catch (error) {\n                console.log(\"failed to start WebsocketProvider\", error);\n                // @TODO: now what? Attempt reconnect?\n            }\n        };\n\n        this.websocket.onmessage = (message: { data: string }) => {\n            this._processMessage(message.data);\n        };\n/*\n        this.websocket.onclose = (event) => {\n            // @TODO: What event.code should we reconnect on?\n            const reconnect = false;\n            if (reconnect) {\n                this.pause(true);\n                if (this.#connect) {\n                    this.#websocket = this.#connect();\n                    this.#websocket.onopen = ...\n                    // @TODO: this requires the super class to rebroadcast; move it there\n                }\n                this._reconnect();\n            }\n        };\n*/\n    }\n\n    async _write(message: string): Promise<void> {\n        this.websocket.send(message);\n    }\n\n    async destroy(): Promise<void> {\n        if (this.#websocket != null) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n        super.destroy();\n    }\n}\n"],"mappings":";;AAEA,SAASA,SAAS,IAAIC,UAAU,QAAQ,SAAS,CAAC,CAAC;AAEnD,SAASC,cAAc,QAAQ,sBAAsB;AAyBrD;;;;;;;;;;AAAA,IAAAC,QAAA,gBAAAC,0BAAA;AAAA,IAAAC,UAAA,gBAAAD,0BAAA;AAUA,OAAM,MAAOE,iBAAkB,SAAQJ,cAAc;EAIjD,IAAIK,SAASA,CAAA;IACT,IAAIC,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,KAAe,IAAI,EAAE;MAAE,MAAM,IAAII,KAAK,CAAC,kBAAkB,CAAC;;IAClE,OAAAD,2BAAA,CAAO,IAAI,EAAAH,UAAA,EAAAA,UAAA;EACf;EAEAK,YAAYC,GAA8C,EAAEC,OAAoB,EAAEC,OAAmC;IACjH,KAAK,CAACD,OAAO,EAAEC,OAAO,CAAC;IAACC,MAAA,CAAAC,cAAA,OAAAZ,QAAA;MAAAa,QAAA;MAAAC,KAAA;IAAA;IAAAH,MAAA,CAAAC,cAAA,OAAAV,UAAA;MAAAW,QAAA;MAAAC,KAAA;IAAA;IACxB,IAAI,OAAON,GAAI,KAAK,QAAQ,EAAE;MAC1BH,2BAAA,KAAI,EAAAL,QAAA,EAAAA,QAAA,IAAY,MAAK;QAAG,OAAO,IAAIF,UAAU,CAACU,GAAG,CAAC;MAAE,CAAC;MACrDH,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,IAAAG,2BAAA,CAAc,IAAI,EAAAL,QAAA,EAAAA,QAAA,GAAW;KACpC,MAAM,IAAI,OAAOQ,GAAI,KAAK,UAAU,EAAE;MACnCH,2BAAA,KAAI,EAAAL,QAAA,EAAAA,QAAA,IAAYQ,GAAG;MACnBH,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,IAAcM,GAAG,EAAE;KAC1B,MAAM;MACHH,2BAAA,KAAI,EAAAL,QAAA,EAAAA,QAAA,IAAY,IAAI;MACpBK,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,IAAcM,GAAG;;IAGzB,IAAI,CAACJ,SAAS,CAACW,MAAM,GAAG,YAAW;MAC/B,IAAI;QACA,MAAM,IAAI,CAACC,MAAM,EAAE;QACnB,IAAI,CAACC,MAAM,EAAE;OAChB,CAAC,OAAOC,KAAK,EAAE;QACZC,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAEF,KAAK,CAAC;QACvD;;IAER,CAAC;IAED,IAAI,CAACd,SAAS,CAACiB,SAAS,GAAIC,OAAyB,IAAI;MACrD,IAAI,CAACC,eAAe,CAACD,OAAO,CAACE,IAAI,CAAC;IACtC,CAAC;IACT;;;;;;;;;;;;;;;EAeI;EAEA,MAAMC,MAAMA,CAACH,OAAe;IACxB,IAAI,CAAClB,SAAS,CAACsB,IAAI,CAACJ,OAAO,CAAC;EAChC;EAEA,MAAMK,OAAOA,CAAA;IACT,IAAItB,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,KAAe,IAAI,EAAE;MACzBG,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,EAAY0B,KAAK,EAAE;MACvBvB,2BAAA,KAAI,EAAAH,UAAA,EAAAA,UAAA,IAAc,IAAI;;IAE1B,KAAK,CAACyB,OAAO,EAAE;EACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}