{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/DELL/Desktop/decentralized-voting-dapp/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport { defineProperties, concat, getBytesCopy, getNumber, hexlify, toBeArray, toBigInt, toNumber, assert, assertArgument\n/*, isError*/ } from \"../../utils/index.js\";\n/**\n * @_ignore:\n */\nexport const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n  return resultNames.get(result);\n}\nfunction setNames(result, names) {\n  resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n  wrapped.error = error;\n  throw wrapped;\n}\nfunction toObject(names, items, deep) {\n  if (names.indexOf(null) >= 0) {\n    return items.map((item, index) => {\n      if (item instanceof Result) {\n        return toObject(getNames(item), item, deep);\n      }\n      return item;\n    });\n  }\n  return names.reduce((accum, name, index) => {\n    let item = items.getValue(name);\n    if (!(name in accum)) {\n      if (deep && item instanceof Result) {\n        item = toObject(getNames(item), item, deep);\n      }\n      accum[name] = item;\n    }\n    return accum;\n  }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nvar _names2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\nexport class Result extends Array {\n  /**\n   *  @private\n   */\n  constructor(...args) {\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    const guard = args[0];\n    let items = args[1];\n    let names = (args[2] || []).slice();\n    let wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    super(items.length);\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    Object.defineProperty(this, _names2, {\n      writable: true,\n      value: void 0\n    });\n    items.forEach((item, index) => {\n      this[index] = item;\n    });\n    // Find all unique keys\n    const nameCounts = names.reduce((accum, name) => {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    setNames(this, Object.freeze(items.map((item, index) => {\n      const name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    })));\n    // Dummy operations to prevent TypeScript from complaining\n    _classPrivateFieldLooseBase(this, _names2)[_names2] = [];\n    if (_classPrivateFieldLooseBase(this, _names2)[_names2] == null) {\n      void _classPrivateFieldLooseBase(this, _names2)[_names2];\n    }\n    if (!wrap) {\n      return;\n    }\n    // A wrapped Result is immutable\n    Object.freeze(this);\n    // Proxy indices and names so we can trap deferred errors\n    const proxy = new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            const index = getNumber(prop, \"%index\");\n            if (index < 0 || index >= this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            const item = target[index];\n            if (item instanceof Error) {\n              throwError(`index ${index}`, item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          const value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function (...args) {\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(this === receiver ? target : this, [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n    setNames(proxy, getNames(this));\n    return proxy;\n  }\n  /**\n   *  Returns the Result as a normal Array. If %%deep%%, any children\n   *  which are Result objects are also converted to a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  toArray(deep) {\n    const result = [];\n    this.forEach((item, index) => {\n      if (item instanceof Error) {\n        throwError(`index ${index}`, item);\n      }\n      if (deep && item instanceof Result) {\n        item = item.toArray(deep);\n      }\n      result.push(item);\n    });\n    return result;\n  }\n  /**\n   *  Returns the Result as an Object with each name-value pair. If\n   *  %%deep%%, any children which are Result objects are also\n   *  converted to an Object.\n   *\n   *  This will throw if any value is unnamed, or if there are\n   *  any outstanding deferred errors.\n   */\n  toObject(deep) {\n    const names = getNames(this);\n    return names.reduce((accum, name, index) => {\n      assert(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n        operation: \"toObject()\"\n      });\n      return toObject(names, this, deep);\n    }, {});\n  }\n  /**\n   *  @_ignore\n   */\n  slice(start, end) {\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start += this.length;\n      if (start < 0) {\n        start = 0;\n      }\n    }\n    if (end == null) {\n      end = this.length;\n    }\n    if (end < 0) {\n      end += this.length;\n      if (end < 0) {\n        end = 0;\n      }\n    }\n    if (end > this.length) {\n      end = this.length;\n    }\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = start; i < end; i++) {\n      result.push(this[i]);\n      names.push(_names[i]);\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  filter(callback, thisArg) {\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      if (callback.call(thisArg, item, i, this)) {\n        result.push(item);\n        names.push(_names[i]);\n      }\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  map(callback, thisArg) {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      result.push(callback.call(thisArg, item, i, this));\n    }\n    return result;\n  }\n  /**\n   *  Returns the value for %%name%%.\n   *\n   *  Since it is possible to have a key whose name conflicts with\n   *  a method on a [[Result]] or its superclass Array, or any\n   *  JavaScript keyword, this ensures all named values are still\n   *  accessible by name.\n   */\n  getValue(name) {\n    const index = getNames(this).indexOf(name);\n    if (index === -1) {\n      return undefined;\n    }\n    const value = this[index];\n    if (value instanceof Error) {\n      throwError(`property ${JSON.stringify(name)}`, value.error);\n    }\n    return value;\n  }\n  /**\n   *  Creates a new [[Result]] for %%items%% with each entry\n   *  also accessible by its corresponding name in %%keys%%.\n   */\n  static fromItems(items, keys) {\n    return new Result(_guard, items, keys);\n  }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nfunction getValue(value) {\n  let bytes = toBeArray(value);\n  assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== WordSize) {\n    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nexport class Coder {\n  // The coder name:\n  //   - address, uint256, tuple, array, etc.\n\n  // The fully expanded type, including composite types:\n  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n\n  // The localName bound in the signature, in this example it is \"baz\":\n  //   - tuple(address foo, uint bar) baz\n\n  // Whether this type is dynamic:\n  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n\n  constructor(name, type, localName, dynamic) {\n    defineProperties(this, {\n      name,\n      type,\n      localName,\n      dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _throwError(message, value) {\n    assertArgument(false, message, this.localName, value);\n  }\n}\n/**\n *  @_ignore\n */\nvar _data = /*#__PURE__*/_classPrivateFieldLooseKey(\"data\");\nvar _dataLength = /*#__PURE__*/_classPrivateFieldLooseKey(\"dataLength\");\nvar _writeData = /*#__PURE__*/_classPrivateFieldLooseKey(\"writeData\");\nexport class Writer {\n  constructor() {\n    Object.defineProperty(this, _writeData, {\n      value: _writeData2\n    });\n    // An array of WordSize lengthed objects to concatenation\n    Object.defineProperty(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _dataLength, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _data)[_data] = [];\n    _classPrivateFieldLooseBase(this, _dataLength)[_dataLength] = 0;\n  }\n  get data() {\n    return concat(_classPrivateFieldLooseBase(this, _data)[_data]);\n  }\n  get length() {\n    return _classPrivateFieldLooseBase(this, _dataLength)[_dataLength];\n  }\n  appendWriter(writer) {\n    return _classPrivateFieldLooseBase(this, _writeData)[_writeData](getBytesCopy(writer.data));\n  }\n  // Arrayish item; pad on the right to *nearest* WordSize\n  writeBytes(value) {\n    let bytes = getBytesCopy(value);\n    const paddingOffset = bytes.length % WordSize;\n    if (paddingOffset) {\n      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));\n    }\n    return _classPrivateFieldLooseBase(this, _writeData)[_writeData](bytes);\n  }\n  // Numeric item; pad on the left *to* WordSize\n  writeValue(value) {\n    return _classPrivateFieldLooseBase(this, _writeData)[_writeData](getValue(value));\n  }\n  // Inserts a numeric place-holder, returning a callback that can\n  // be used to asjust the value later\n  writeUpdatableValue() {\n    const offset = _classPrivateFieldLooseBase(this, _data)[_data].length;\n    _classPrivateFieldLooseBase(this, _data)[_data].push(Padding);\n    _classPrivateFieldLooseBase(this, _dataLength)[_dataLength] += WordSize;\n    return value => {\n      _classPrivateFieldLooseBase(this, _data)[_data][offset] = getValue(value);\n    };\n  }\n}\n/**\n *  @_ignore\n */\nfunction _writeData2(data) {\n  _classPrivateFieldLooseBase(this, _data)[_data].push(data);\n  _classPrivateFieldLooseBase(this, _dataLength)[_dataLength] += data.length;\n  return data.length;\n}\nvar _data2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"data\");\nvar _offset = /*#__PURE__*/_classPrivateFieldLooseKey(\"offset\");\nvar _bytesRead = /*#__PURE__*/_classPrivateFieldLooseKey(\"bytesRead\");\nvar _parent = /*#__PURE__*/_classPrivateFieldLooseKey(\"parent\");\nvar _maxInflation = /*#__PURE__*/_classPrivateFieldLooseKey(\"maxInflation\");\nvar _incrementBytesRead = /*#__PURE__*/_classPrivateFieldLooseKey(\"incrementBytesRead\");\nvar _peekBytes = /*#__PURE__*/_classPrivateFieldLooseKey(\"peekBytes\");\nexport class Reader {\n  constructor(data, allowLoose, maxInflation) {\n    Object.defineProperty(this, _peekBytes, {\n      value: _peekBytes2\n    });\n    Object.defineProperty(this, _incrementBytesRead, {\n      value: _incrementBytesRead2\n    });\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    Object.defineProperty(this, _data2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _offset, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _bytesRead, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _parent, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _maxInflation, {\n      writable: true,\n      value: void 0\n    });\n    defineProperties(this, {\n      allowLoose: !!allowLoose\n    });\n    _classPrivateFieldLooseBase(this, _data2)[_data2] = getBytesCopy(data);\n    _classPrivateFieldLooseBase(this, _bytesRead)[_bytesRead] = 0;\n    _classPrivateFieldLooseBase(this, _parent)[_parent] = null;\n    _classPrivateFieldLooseBase(this, _maxInflation)[_maxInflation] = maxInflation != null ? maxInflation : 1024;\n    _classPrivateFieldLooseBase(this, _offset)[_offset] = 0;\n  }\n  get data() {\n    return hexlify(_classPrivateFieldLooseBase(this, _data2)[_data2]);\n  }\n  get dataLength() {\n    return _classPrivateFieldLooseBase(this, _data2)[_data2].length;\n  }\n  get consumed() {\n    return _classPrivateFieldLooseBase(this, _offset)[_offset];\n  }\n  get bytes() {\n    return new Uint8Array(_classPrivateFieldLooseBase(this, _data2)[_data2]);\n  }\n  // Create a sub-reader with the same underlying data, but offset\n  subReader(offset) {\n    const reader = new Reader(_classPrivateFieldLooseBase(this, _data2)[_data2].slice(_classPrivateFieldLooseBase(this, _offset)[_offset] + offset), this.allowLoose, _classPrivateFieldLooseBase(this, _maxInflation)[_maxInflation]);\n    _classPrivateFieldLooseBase(reader, _parent)[_parent] = this;\n    return reader;\n  }\n  // Read bytes\n  readBytes(length, loose) {\n    let bytes = _classPrivateFieldLooseBase(this, _peekBytes)[_peekBytes](0, length, !!loose);\n    _classPrivateFieldLooseBase(this, _incrementBytesRead)[_incrementBytesRead](length);\n    _classPrivateFieldLooseBase(this, _offset)[_offset] += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  // Read a numeric values\n  readValue() {\n    return toBigInt(this.readBytes(WordSize));\n  }\n  readIndex() {\n    return toNumber(this.readBytes(WordSize));\n  }\n}\nfunction _incrementBytesRead2(count) {\n  if (_classPrivateFieldLooseBase(this, _parent)[_parent]) {\n    return _classPrivateFieldLooseBase(_classPrivateFieldLooseBase(this, _parent)[_parent], _incrementBytesRead)[_incrementBytesRead](count);\n  }\n  _classPrivateFieldLooseBase(this, _bytesRead)[_bytesRead] += count;\n  // Check for excessive inflation (see: #4537)\n  assert(_classPrivateFieldLooseBase(this, _maxInflation)[_maxInflation] < 1 || _classPrivateFieldLooseBase(this, _bytesRead)[_bytesRead] <= _classPrivateFieldLooseBase(this, _maxInflation)[_maxInflation] * this.dataLength, `compressed ABI data exceeds inflation ratio of ${_classPrivateFieldLooseBase(this, _maxInflation)[_maxInflation]} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n    buffer: getBytesCopy(_classPrivateFieldLooseBase(this, _data2)[_data2]),\n    offset: _classPrivateFieldLooseBase(this, _offset)[_offset],\n    length: count,\n    info: {\n      bytesRead: _classPrivateFieldLooseBase(this, _bytesRead)[_bytesRead],\n      dataLength: this.dataLength\n    }\n  });\n}\nfunction _peekBytes2(offset, length, loose) {\n  let alignedLength = Math.ceil(length / WordSize) * WordSize;\n  if (_classPrivateFieldLooseBase(this, _offset)[_offset] + alignedLength > _classPrivateFieldLooseBase(this, _data2)[_data2].length) {\n    if (this.allowLoose && loose && _classPrivateFieldLooseBase(this, _offset)[_offset] + length <= _classPrivateFieldLooseBase(this, _data2)[_data2].length) {\n      alignedLength = length;\n    } else {\n      assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: getBytesCopy(_classPrivateFieldLooseBase(this, _data2)[_data2]),\n        length: _classPrivateFieldLooseBase(this, _data2)[_data2].length,\n        offset: _classPrivateFieldLooseBase(this, _offset)[_offset] + alignedLength\n      });\n    }\n  }\n  return _classPrivateFieldLooseBase(this, _data2)[_data2].slice(_classPrivateFieldLooseBase(this, _offset)[_offset], _classPrivateFieldLooseBase(this, _offset)[_offset] + alignedLength);\n}","map":{"version":3,"names":["defineProperties","concat","getBytesCopy","getNumber","hexlify","toBeArray","toBigInt","toNumber","assert","assertArgument","WordSize","Padding","Uint8Array","passProperties","_guard","resultNames","WeakMap","getNames","result","get","setNames","names","set","throwError","name","error","wrapped","Error","toObject","items","deep","indexOf","map","item","index","Result","reduce","accum","getValue","_names2","_classPrivateFieldLooseKey","Array","constructor","args","guard","slice","wrap","length","Object","defineProperty","writable","value","forEach","nameCounts","Map","freeze","_classPrivateFieldLooseBase","proxy","Proxy","target","prop","receiver","match","RangeError","Reflect","Function","apply","toArray","push","operation","start","end","_names","i","filter","callback","thisArg","call","undefined","JSON","stringify","fromItems","keys","checkResultErrors","errors","checkErrors","path","object","isArray","key","childPath","bytes","buffer","offset","Coder","type","localName","dynamic","_throwError","message","_data","_dataLength","_writeData","Writer","_writeData2","data","appendWriter","writer","writeBytes","paddingOffset","writeValue","writeUpdatableValue","_data2","_offset","_bytesRead","_parent","_maxInflation","_incrementBytesRead","_peekBytes","Reader","allowLoose","maxInflation","_peekBytes2","_incrementBytesRead2","dataLength","consumed","subReader","reader","readBytes","loose","readValue","readIndex","count","info","bytesRead","alignedLength","Math","ceil"],"sources":["C:\\Users\\DELL\\Desktop\\decentralized-voting-dapp\\src\\node_modules\\ethers\\src.ts\\abi\\coders\\abstract-coder.ts"],"sourcesContent":["\nimport {\n    defineProperties, concat, getBytesCopy, getNumber, hexlify,\n    toBeArray, toBigInt, toNumber,\n    assert, assertArgument\n    /*, isError*/\n} from \"../../utils/index.js\";\n\nimport type { BigNumberish, BytesLike } from \"../../utils/index.js\";\n\n/**\n * @_ignore:\n */\nexport const WordSize: number = 32;\nconst Padding = new Uint8Array(WordSize);\n\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [ \"then\" ];\n\nconst _guard = { };\n\nconst resultNames: WeakMap<Result, ReadonlyArray<null | string>> = new WeakMap();\n\nfunction getNames(result: Result): ReadonlyArray<null | string> {\n    return resultNames.get(result)!;\n}\nfunction setNames(result: Result, names: ReadonlyArray<null | string>): void {\n    resultNames.set(result, names);\n}\n\nfunction throwError(name: string, error: Error): never {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${ name }`);\n    (<any>wrapped).error = error;\n    throw wrapped;\n}\n\nfunction toObject(names: ReadonlyArray<null | string>, items: Result, deep?: boolean): Record<string, any> | Array<any> {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index) => {\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n\n    return (<Array<string>>names).reduce((accum, name, index) => {\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, <Record<string, any>>{ });\n}\n\n\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array<any> {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @private\n     */\n    constructor(...args: Array<any>) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items: Array<any> = args[1];\n        let names: Array<null | string> = (args[2] || [ ]).slice();\n\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [ ];\n            wrap = false;\n        }\n\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof(name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, <Map<string, number>>(new Map()));\n\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [ ];\n        if (this.#names == null) { void(this.#names); }\n\n        if (!wrap) { return; }\n\n        // A wrapped Result is immutable\n        Object.freeze(this);\n\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"string\") {\n\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${ index }`, item);\n                        }\n                        return item;\n                    }\n\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(this: any, ...args: Array<any>) {\n                            return value.apply((this === receiver) ? target: this, args);\n                        };\n\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target: this, [ prop ]);\n                    }\n                }\n\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(deep?: boolean): Array<any> {\n        const result: Array<any> = [ ];\n        this.forEach((item, index) => {\n            if (item instanceof Error) { throwError(`index ${ index }`, item); }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(deep?: boolean): Record<string, any> {\n        const names = getNames(this);\n        return names.reduce((accum, name, index) => {\n\n            assert(name != null, `value at index ${ index } unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n\n            return toObject(names, this, deep);\n        }, <Record<string, any>>{});\n    }\n\n    /**\n     *  @_ignore\n     */\n    slice(start?: number | undefined, end?: number | undefined): Result {\n        if (start == null) { start = 0; }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) { start = 0; }\n        }\n\n        if (end == null) { end = this.length; }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) { end = 0; }\n        }\n        if (end > this.length) { end = this.length; }\n\n        const _names = getNames(this);\n\n        const result: Array<any> = [ ], names: Array<null | string> = [ ];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    filter(callback: (el: any, index: number, array: Result) => boolean, thisArg?: any): Result {\n        const _names = getNames(this);\n\n        const result: Array<any> = [ ], names: Array<null | string> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    map<T extends any = any>(callback: (el: any, index: number, array: Result) => T, thisArg?: any): Array<T> {\n        const result: Array<T> = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            result.push(callback.call(thisArg, item, i, this));\n        }\n\n        return result;\n    }\n\n\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name: string): any {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) { return undefined; }\n\n        const value = this[index];\n\n        if (value instanceof Error) {\n            throwError(`property ${ JSON.stringify(name) }`, (<any>value).error);\n        }\n\n        return value;\n    }\n\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items: Array<any>, keys?: Array<null | string>): Result {\n        return new Result(_guard, items, keys);\n    }\n}\n\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error: any) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nfunction getValue(value: BigNumberish): Uint8Array {\n    let bytes = toBeArray(value);\n\n    assert (bytes.length <= WordSize, \"value out-of-bounds\",\n        \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([ Padding.slice(bytes.length % WordSize), bytes ]));\n    }\n\n    return bytes;\n}\n\n/**\n *  @_ignore\n */\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name!: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type!: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName!: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic!: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        defineProperties<Coder>(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n\n    _throwError(message: string, value: any): never {\n        assertArgument(false, message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data: Array<Uint8Array>;\n    #dataLength: number;\n\n    constructor() {\n        this.#data = [ ];\n        this.#dataLength = 0;\n    }\n\n    get data(): string {\n        return concat(this.#data);\n    }\n    get length(): number { return this.#dataLength; }\n\n    #writeData(data: Uint8Array): number {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([ bytes, Padding.slice(paddingOffset) ]))\n        }\n        return this.#writeData(bytes);\n    }\n\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value: BigNumberish): number {\n        return this.#writeData(getValue(value));\n    }\n\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value: BigNumberish) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    readonly allowLoose!: boolean;\n\n    readonly #data: Uint8Array;\n    #offset: number;\n\n    #bytesRead: number;\n    #parent: null | Reader;\n    #maxInflation: number;\n\n    constructor(data: BytesLike, allowLoose?: boolean, maxInflation?: number) {\n        defineProperties<Reader>(this, { allowLoose: !!allowLoose });\n\n        this.#data = getBytesCopy(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = (maxInflation != null) ? maxInflation: 1024;\n\n        this.#offset = 0;\n    }\n\n    get data(): string { return hexlify(this.#data); }\n    get dataLength(): number { return this.#data.length; }\n    get consumed(): number { return this.#offset; }\n    get bytes(): Uint8Array { return new Uint8Array(this.#data); }\n\n    #incrementBytesRead(count: number): void {\n        if (this.#parent) { return this.#parent.#incrementBytesRead(count); }\n\n        this.#bytesRead += count;\n\n        // Check for excessive inflation (see: #4537)\n        assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${ this.#maxInflation } ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`,  \"BUFFER_OVERRUN\", {\n            buffer: getBytesCopy(this.#data), offset: this.#offset,\n            length: count, info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n\n    #peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength)\n    }\n\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset: number): Reader {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n\n    // Read bytes\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    // Read a numeric values\n    readValue(): bigint {\n        return toBigInt(this.readBytes(WordSize));\n    }\n\n    readIndex(): number {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}